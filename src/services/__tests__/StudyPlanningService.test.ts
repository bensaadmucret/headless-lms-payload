import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import {
  StudyPlanningService,
  type StudyPlanDocument,
  type StudyPlanSlotInput,
  type WeeklyPlanResponse,
} from '../StudyPlanningService';

type MockPayloadClient = {
  find: ReturnType<typeof vi.fn>;
  create: ReturnType<typeof vi.fn>;
  update: ReturnType<typeof vi.fn>;
};

const spacedRepetitionMock = vi.hoisted(() => {
  const instance = {
    generateReviewSession: vi.fn(),
  };

  return {
    instance,
    constructor: vi.fn(() => instance),
  };
});

const payloadMock = vi.hoisted(() => {
  return {
    find: vi.fn(),
    create: vi.fn(),
    update: vi.fn(),
  };
});

vi.mock('../SpacedRepetitionSchedulingService', () => ({
  SpacedRepetitionSchedulingService: spacedRepetitionMock.constructor,
}));

vi.mock('payload', () => ({
  default: payloadMock,
}));

describe('StudyPlanningService', () => {
  let payloadClient: MockPayloadClient;
  let service: StudyPlanningService;

  beforeEach(() => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date('2024-01-10T10:00:00.000Z'));

    payloadClient = payloadMock as unknown as MockPayloadClient;

    spacedRepetitionMock.instance.generateReviewSession.mockReset();
    spacedRepetitionMock.constructor.mockClear();

    payloadMock.find.mockReset();
    payloadMock.create.mockReset();
    payloadMock.update.mockReset();

    payloadMock.find.mockResolvedValue({ docs: [] });
    payloadMock.create.mockResolvedValue({ id: 'plan-id' });
    payloadMock.update.mockResolvedValue({ id: 'plan-id' });

    service = new StudyPlanningService(payloadClient as unknown as any);
  });

  afterEach(() => {
    vi.useRealTimers();
    vi.clearAllMocks();
  });

  it("crée un planning hebdomadaire lorsqu'aucun document n'existe", async () => {
    payloadClient.find.mockResolvedValue({ docs: [] });

    const createdPlan: StudyPlanDocument = {
      id: 'plan-1',
      title: 'Planning hebdomadaire',
      planType: 'weekly',
      status: 'draft',
      user: 42,
      weekStart: '2024-01-08T00:00:00.000Z',
      weekEnd: '2024-01-14T23:59:59.999Z',
      slots: [],
      plannedDurationMinutes: 0,
      actualDurationMinutes: 0,
      autoGenerated: false,
      metadata: null,
    };

    payloadClient.create.mockResolvedValue(createdPlan);

    const result = await service.getWeeklyPlan(42, '2024-01-10');

    expect(payloadClient.find).toHaveBeenCalledWith(
      expect.objectContaining({
        collection: 'study-plans',
        where: expect.objectContaining({
          user: { equals: 42 },
          planType: { equals: 'weekly' },
        }),
      })
    );

    expect(payloadClient.create).toHaveBeenCalledWith(
      expect.objectContaining({
        collection: 'study-plans',
        data: expect.objectContaining({
          user: 42,
          planType: 'weekly',
          status: 'draft',
        }),
      })
    );

    expect(result.plan).toEqual(createdPlan);
    expect(result.summary).toEqual({ plannedMinutes: 0, completedMinutes: 0, slotsCount: 0 });
  });

  it('récupère un planning existant sans le recréer', async () => {
    const existingPlan: StudyPlanDocument = {
      id: 'plan-2',
      title: 'Planning existant',
      planType: 'weekly',
      status: 'active',
      user: 42,
      weekStart: '2024-01-08T00:00:00.000Z',
      weekEnd: '2024-01-14T23:59:59.999Z',
      slots: [
        {
          slotId: 'slot-1',
          title: 'Session',
          startsAt: '2024-01-09T18:00:00.000Z',
          durationMinutes: 60,
          activityType: 'study_session',
          status: 'planned',
        },
      ],
      plannedDurationMinutes: 60,
      actualDurationMinutes: 0,
      autoGenerated: false,
      metadata: null,
    };

    payloadClient.find.mockResolvedValue({ docs: [existingPlan] });

    const result = await service.getWeeklyPlan(42, '2024-01-10');

    expect(payloadClient.create).not.toHaveBeenCalled();
    expect(result.plan).toEqual(existingPlan);
    expect(result.summary).toEqual({ plannedMinutes: 60, completedMinutes: 0, slotsCount: 1 });
  });

  it('met à jour un planning hebdomadaire', async () => {
    const existingPlan: StudyPlanDocument = {
      id: 'plan-3',
      title: 'Planning initial',
      planType: 'weekly',
      status: 'draft',
      user: 42,
      weekStart: '2024-01-08T00:00:00.000Z',
      weekEnd: '2024-01-14T23:59:59.999Z',
      slots: [],
      plannedDurationMinutes: 0,
      actualDurationMinutes: 0,
      autoGenerated: false,
      metadata: null,
    };

    const updatedPlan: StudyPlanDocument = {
      ...existingPlan,
      title: 'Planning mis à jour',
      objective: 'Réviser chapitre 1',
    };

    const weeklyResponse: WeeklyPlanResponse = {
      plan: existingPlan,
      weekStart: existingPlan.weekStart!,
      weekEnd: existingPlan.weekEnd!,
      summary: { plannedMinutes: 0, completedMinutes: 0, slotsCount: 0 },
    };

    payloadClient.find.mockResolvedValue({ docs: [existingPlan] });
    payloadClient.update.mockResolvedValue(updatedPlan);

    service.getWeeklyPlan = vi.fn().mockResolvedValue(weeklyResponse);

    const result = await service.updateWeeklyPlan(42, {
      weekStart: '2024-01-08T00:00:00.000Z',
      title: 'Planning mis à jour',
      objective: 'Réviser chapitre 1',
    });

    expect(payloadClient.update).toHaveBeenCalledWith(
      expect.objectContaining({
        collection: 'study-plans',
        id: existingPlan.id,
        data: expect.objectContaining({
          title: 'Planning mis à jour',
          objective: 'Réviser chapitre 1',
        }),
      })
    );

    expect(result.plan).toEqual(updatedPlan);
  });

  it('ajoute ou met à jour un créneau', async () => {
    const existingSlots: StudyPlanSlotInput[] = [
      {
        slotId: 'slot-1',
        title: 'Session existante',
        startsAt: '2024-01-09T18:00:00.000Z',
        durationMinutes: 45,
        activityType: 'quiz',
        status: 'planned',
      },
    ];

    const newSlot: StudyPlanSlotInput = {
      title: 'Nouveau créneau',
      startsAt: '2024-01-10T17:00:00.000Z',
      durationMinutes: 30,
      activityType: 'flashcards',
    };

    const existingPlan: StudyPlanDocument = {
      id: 'plan-4',
      title: 'Planning hebdomadaire',
      planType: 'weekly',
      status: 'active',
      user: 42,
      weekStart: '2024-01-08T00:00:00.000Z',
      weekEnd: '2024-01-14T23:59:59.999Z',
      slots: existingSlots,
      plannedDurationMinutes: 45,
      actualDurationMinutes: 0,
      autoGenerated: false,
      metadata: null,
    };

    const updatedPlan: StudyPlanDocument = {
      ...existingPlan,
      slots: [...existingSlots, { ...newSlot, slotId: 'slot-2', status: 'planned' }],
      plannedDurationMinutes: 75,
    };

    payloadClient.find.mockResolvedValue({
      docs: [existingPlan],
    });

    payloadClient.update.mockResolvedValue(updatedPlan);

    const result = await service.upsertSlot(42, '2024-01-08T00:00:00.000Z', newSlot);

    expect(result.plan.slots).toHaveLength(2);
    expect(result.plan.plannedDurationMinutes).toBe(75);
    expect(payloadClient.update).toHaveBeenCalledWith(
      expect.objectContaining({
        collection: 'study-plans',
        data: expect.objectContaining({
          plannedDurationMinutes: 75,
        }),
      })
    );
  });

  it('génère des suggestions auto-remplies et les applique', async () => {
    const existingPlan: StudyPlanDocument = {
      id: 'plan-5',
      title: 'Planning hebdomadaire',
      planType: 'weekly',
      status: 'active',
      user: 42,
      weekStart: '2024-01-08T00:00:00.000Z',
      weekEnd: '2024-01-14T23:59:59.999Z',
      slots: [],
      plannedDurationMinutes: 0,
      actualDurationMinutes: 0,
      autoGenerated: false,
      metadata: null,
    };

    const suggestionSlot: StudyPlanSlotInput = {
      slotId: 'auto-1',
      title: 'Révision SRS (5 cartes)',
      startsAt: '2024-01-08T18:00:00.000Z',
      durationMinutes: 30,
      activityType: 'spaced_repetition',
      status: 'planned',
      metadata: { scheduleId: 'schedule-1', cardIds: ['q1', 'q2'] },
    };

    payloadClient.find.mockResolvedValue({ docs: [existingPlan] });
    spacedRepetitionMock.instance.generateReviewSession.mockResolvedValue({
      scheduleId: 'schedule-1',
      cardsToReview: [
        { questionId: 'q1' },
        { questionId: 'q2' },
      ],
      estimatedDuration: 30,
    });

    const updatedPlan: StudyPlanDocument = {
      ...existingPlan,
      slots: [suggestionSlot],
      plannedDurationMinutes: 30,
      autoGenerated: true,
    };

    payloadClient.update.mockResolvedValue(updatedPlan);

    const result = await service.generateAutofillSuggestions(
      42,
      '2024-01-08T00:00:00.000Z',
      { preferredHour: 18, maxCards: 10, sessionDuration: 30 },
      true
    );

    expect(spacedRepetitionMock.instance.generateReviewSession).toHaveBeenCalledWith('42', 10, 30);
    expect(result.applied).toBe(true);
    expect(result.plan.slots).toEqual([suggestionSlot]);
    expect(payloadClient.update).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          plannedDurationMinutes: 30,
          autoGenerated: true,
        }),
      })
    );
  });
});
