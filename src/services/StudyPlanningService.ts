import payload from 'payload';
import { SpacedRepetitionSchedulingService } from './SpacedRepetitionSchedulingService';

export type PlanningActivityType =
  | 'spaced_repetition'
  | 'flashcards'
  | 'quiz'
  | 'adaptive_quiz'
  | 'study_session'
  | 'review'
  | 'mock_exam'
  | 'break'
  | 'custom';

export interface StudyPlanSlotInput {
  slotId?: string;
  title: string;
  notes?: string;
  startsAt: string;
  durationMinutes: number;
  activityType: PlanningActivityType;
  status?: 'planned' | 'in_progress' | 'completed' | 'missed' | 'canceled';
  linkedQuiz?: string | number | null;
  linkedStudySession?: string | number | null;
  metadata?: Record<string, unknown> | null;
}

export interface StudyPlanDocument {
  id: string | number;
  title: string;
  planType: 'weekly' | 'spaced_repetition' | 'custom';
  status: 'draft' | 'active' | 'completed' | 'archived';
  user: string | number | { id: string | number };
  weekStart?: string | null;
  weekEnd?: string | null;
  objective?: string | null;
  plannedDurationMinutes?: number | null;
  actualDurationMinutes?: number | null;
  autoGenerated?: boolean;
  slots: StudyPlanSlotInput[];
  metadata?: Record<string, unknown> | null;
  srsScheduleData?: string | null;
}

export interface WeeklyPlanResponse {
  plan: StudyPlanDocument;
  weekStart: string;
  weekEnd: string;
  summary: {
    plannedMinutes: number;
    completedMinutes: number;
    slotsCount: number;
  };
}

export interface AutofillOptions {
  preferredHour?: number;
  maxCards?: number;
  sessionDuration?: number;
}

export interface AutofillResult {
  suggestions: StudyPlanSlotInput[];
  applied: boolean;
  plan: StudyPlanDocument;
}

export class StudyPlanningService {
  private payloadClient: any;
  private spacedRepetitionService: SpacedRepetitionSchedulingService;

  constructor(payloadInstance: any = payload) {
    this.payloadClient = payloadInstance as any;
    this.spacedRepetitionService = new SpacedRepetitionSchedulingService();
  }

  private normalizeUserId(userId: string | number): string | number {
    if (typeof userId === 'number') {
      return userId;
    }

    if (typeof userId === 'string') {
      const trimmed = userId.trim();
      if (trimmed.length === 0) {
        throw new Error('Identifiant utilisateur manquant');
      }
      return trimmed;
    }

    throw new Error(`Identifiant utilisateur invalide: ${String(userId)}`);
  }

  private isRecord(value: unknown): value is Record<string, unknown> {
    return typeof value === 'object' && value !== null && !Array.isArray(value);
  }

  private sanitizeSlot(slot: unknown): StudyPlanSlotInput | null {
    if (!this.isRecord(slot)) {
      return null;
    }

    const { title, notes, startsAt, durationMinutes, activityType, status } = slot;

    if (typeof title !== 'string' || typeof startsAt !== 'string' || typeof activityType !== 'string') {
      return null;
    }

    const normalizedSlot: StudyPlanSlotInput = {
      slotId: typeof slot.slotId === 'string' ? slot.slotId : undefined,
      title,
      notes: typeof notes === 'string' ? notes : undefined,
      startsAt,
      durationMinutes: typeof durationMinutes === 'number' ? durationMinutes : 0,
      activityType: activityType as StudyPlanSlotInput['activityType'],
      status: typeof status === 'string' ? (status as StudyPlanSlotInput['status']) : undefined,
      linkedQuiz:
        typeof slot.linkedQuiz === 'string' || typeof slot.linkedQuiz === 'number'
          ? (slot.linkedQuiz as StudyPlanSlotInput['linkedQuiz'])
          : undefined,
      linkedStudySession:
        typeof slot.linkedStudySession === 'string' || typeof slot.linkedStudySession === 'number'
          ? (slot.linkedStudySession as StudyPlanSlotInput['linkedStudySession'])
          : undefined,
      metadata: this.isRecord(slot.metadata) ? (slot.metadata as Record<string, unknown>) : undefined,
    };

    return normalizedSlot;
  }

  private sanitizeSlots(slots: unknown): StudyPlanSlotInput[] {
    if (!Array.isArray(slots)) {
      return [];
    }

    return slots
      .map((slot) => this.sanitizeSlot(slot))
      .filter((slot): slot is StudyPlanSlotInput => slot !== null);
  }

  private normalizePlan(plan: StudyPlanDocument): StudyPlanDocument {
    return {
      ...plan,
      slots: this.sanitizeSlots(plan.slots),
    };
  }

  private getWeekRange(date?: string): { weekStart: Date; weekEnd: Date } {
    const baseDate = date ? new Date(date) : new Date();
    if (Number.isNaN(baseDate.getTime())) {
      throw new Error(`Date fournie invalide: ${date}`);
    }

    const weekStart = new Date(baseDate);
    weekStart.setHours(0, 0, 0, 0);
    const day = weekStart.getDay();
    const diffToMonday = day === 0 ? -6 : 1 - day;
    weekStart.setDate(weekStart.getDate() + diffToMonday);

    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    weekEnd.setHours(23, 59, 59, 999);

    return { weekStart, weekEnd };
  }

  private buildWeekSummary(plan: StudyPlanDocument) {
    const rawSlots = Array.isArray(plan.slots) ? plan.slots : [];
    const validSlots = rawSlots.filter((slot): slot is StudyPlanSlotInput => {
      const isValid = Boolean(slot && typeof slot === 'object');
      if (!isValid) {
        console.warn('[StudyPlanningService] Créneau invalide détecté lors du calcul du résumé', {
          slot,
          planId: plan.id,
        });
      }
      return isValid;
    });

    const plannedMinutes = validSlots.reduce((total, slot) => total + (slot.durationMinutes || 0), 0);
    const completedMinutes = validSlots
      .filter((slot) => slot.status === 'completed')
      .reduce((total, slot) => total + (slot.durationMinutes || 0), 0);

    return {
      plannedMinutes,
      completedMinutes,
      slotsCount: validSlots.length,
    };
  }

  private generateSlotId(): string {
    return `slot_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
  }

  async getWeeklyPlan(userId: string | number, startDate?: string): Promise<WeeklyPlanResponse> {
    const normalizedUserId = this.normalizeUserId(userId);
    const { weekStart, weekEnd } = this.getWeekRange(startDate);
    const weekStartISO = weekStart.toISOString();
    const weekEndISO = weekEnd.toISOString();

    const existing = await this.payloadClient.find({
      collection: 'study-plans',
      where: {
        user: { equals: normalizedUserId },
        planType: { equals: 'weekly' },
        weekStart: { equals: weekStartISO },
      },
      limit: 1,
    });

    let plan: StudyPlanDocument;

    if (existing.docs.length > 0) {
      plan = existing.docs[0] as StudyPlanDocument;
    } else {
      const created = await this.payloadClient.create({
        collection: 'study-plans',
        data: {
          title: 'Planning hebdomadaire',
          user: normalizedUserId,
          planType: 'weekly',
          status: 'draft',
          weekStart: weekStartISO,
          weekEnd: weekEndISO,
          slots: [],
          plannedDurationMinutes: 0,
          actualDurationMinutes: 0,
          autoGenerated: false,
        },
      });

      plan = created as StudyPlanDocument;
    }

    const normalizedPlan = this.normalizePlan(plan);
    const summary = this.buildWeekSummary(normalizedPlan);

    return {
      plan: normalizedPlan,
      weekStart: weekStartISO,
      weekEnd: weekEndISO,
      summary,
    };
  }

  async updateWeeklyPlan(
    userId: string | number,
    payload: Partial<StudyPlanDocument> & { weekStart: string }
  ): Promise<WeeklyPlanResponse> {
    const normalizedUserId = this.normalizeUserId(userId);
    const { weekStart: weekStartDate } = payload;
    const { weekStart, weekEnd } = this.getWeekRange(weekStartDate);
    const weekStartISO = weekStart.toISOString();
    const weekEndISO = weekEnd.toISOString();

    const current = await this.getWeeklyPlan(normalizedUserId, weekStartISO);

    const payloadSlots = (payload as unknown as Record<string, unknown>)?.slots;
    const sanitizedSlots =
      Array.isArray(payloadSlots) && payloadSlots.length > 0
        ? this.sanitizeSlots(payloadSlots)
        : current.plan.slots;

    const updated = await this.payloadClient.update({
      collection: 'study-plans',
      id: current.plan.id,
      data: {
        ...current.plan,
        ...payload,
        weekStart: weekStartISO,
        weekEnd: weekEndISO,
        slots: sanitizedSlots,
      },
    });

    const plan = this.normalizePlan(updated as StudyPlanDocument);
    const summary = this.buildWeekSummary(plan);

    return {
      plan,
      weekStart: weekStartISO,
      weekEnd: weekEndISO,
      summary,
    };
  }

  async upsertSlot(
    userId: string | number,
    weekStart: string,
    slotInput: StudyPlanSlotInput
  ): Promise<WeeklyPlanResponse> {
    const normalizedUserId = this.normalizeUserId(userId);
    const current = await this.getWeeklyPlan(normalizedUserId, weekStart);

    const slots = Array.isArray(current.plan.slots) ? [...current.plan.slots] : [];
    const slotId = slotInput.slotId || this.generateSlotId();
    const normalizedSlot: StudyPlanSlotInput = {
      ...slotInput,
      slotId,
      status: slotInput.status ?? 'planned',
    };

    const existingIndex = slots.findIndex((slot) => slot.slotId === slotId);
    if (existingIndex >= 0) {
      slots[existingIndex] = {
        ...slots[existingIndex],
        ...normalizedSlot,
      };
    } else {
      slots.push(normalizedSlot);
    }

    const updated = await this.payloadClient.update({
      collection: 'study-plans',
      id: current.plan.id,
      data: {
        ...current.plan,
        slots,
        plannedDurationMinutes: slots.reduce((total, slot) => total + (slot.durationMinutes || 0), 0),
      },
    });

    const plan = this.normalizePlan(updated as StudyPlanDocument);
    const summary = this.buildWeekSummary(plan);

    return {
      plan,
      weekStart: current.weekStart,
      weekEnd: current.weekEnd,
      summary,
    };
  }

  async generateAutofillSuggestions(
    userId: string | number,
    weekStart: string,
    options: AutofillOptions = {},
    apply = false
  ): Promise<AutofillResult> {
    const normalizedUserId = this.normalizeUserId(userId);
    const { plan, weekStart: weekStartISO } = await this.getWeeklyPlan(normalizedUserId, weekStart);

    const { preferredHour = 18, maxCards = 20, sessionDuration = 30 } = options;

    const reviewSession = await this.spacedRepetitionService.generateReviewSession(
      String(normalizedUserId),
      maxCards,
      sessionDuration
    );

    const suggestions: StudyPlanSlotInput[] = [];

    if (reviewSession) {
      const sessionDate = new Date(weekStartISO);
      sessionDate.setHours(preferredHour, 0, 0, 0);

      const suggestion: StudyPlanSlotInput = {
        slotId: this.generateSlotId(),
        title: `Révision SRS (${reviewSession.cardsToReview.length} cartes)`,
        startsAt: sessionDate.toISOString(),
        durationMinutes: reviewSession.estimatedDuration,
        activityType: 'spaced_repetition',
        status: 'planned',
        metadata: {
          scheduleId: reviewSession.scheduleId,
          cardIds: reviewSession.cardsToReview.map((card) => card.questionId),
        },
      };

      suggestions.push(suggestion);
    }

    let updatedPlan = plan;

    if (apply && suggestions.length > 0) {
      const mergedSlots = [...plan.slots, ...suggestions];
      const plannedMinutes = mergedSlots.reduce((total, slot) => total + (slot.durationMinutes || 0), 0);
      const updated = await this.payloadClient.update({
        collection: 'study-plans',
        id: plan.id,
        data: {
          ...plan,
          slots: mergedSlots,
          autoGenerated: true,
          plannedDurationMinutes: plannedMinutes,
        },
      });

      updatedPlan = this.normalizePlan(updated as StudyPlanDocument);
    }

    const summary = this.buildWeekSummary(updatedPlan);

    return {
      suggestions,
      applied: suggestions.length > 0 && apply,
      plan: updatedPlan,
    };
  }
}
